---
description:
globs:
alwaysApply: true
---

This provides the standards for writing code:

- Keep the components as pure and simple as possible
- Icons should be imported from 'react-icons'
- We are using react-toastify for toasts
- constants should have complete UPPERCASE
- filenames and variables should follow camelCase
- Code should be clean and un-breakable
- When accessing attributes of an object always use '?' so that we don't run into runtime errors
- For any errors in the page to display use the Error component from functional components
- query params should be fetched from useRouter hooks

1. Module Structure

- Every module must have the following folders (create if needed):
- components/ — All React components specific to the module.
- hooks/ — All custom hooks, especially those for data fetching.
- pages/ — Page-level components, mapped to routes.
- services/ — API service functions (all API calls).
- utils/ — Helper functions/constants used across the module.
- Container module is special: it handles app-wide concerns (auth, sidebar, etc.).

2. Component Design

- Base components (in /src/common/base) are atomic, pure, and only depend on props.
- Functional components (in /src/common/functional) can have state and use base components.
- Module components should:
- Be as pure as possible.
- Use base/functional/common components whenever possible.
- Handle all possible error and loading states gracefully.
- Never assume data is always present; always check for null/undefined/empty.

3. Hooks & Data Fetching

- All data fetching must be done via custom hooks in the hooks/ folder.
- Each hook should:
- Map 1:1 to a service function.
- Return sensible fallback values ([] for lists, null for objects) if the API call fails or returns nothing.
- Never throw errors; always handle errors internally and return fallback values.
- Expose loading, error, and refetch states.

4. Services & API Calls

- All API calls must be in the services/ folder and use the shared request function from /src/common/util/api.util.js.
- The request function must:
- Always use try/catch.
- Never throw errors; always return null on failure.
- Show user-friendly toast notifications for network/API errors.
- Log errors to the console for debugging.
- Service functions must validate input parameters and handle missing/invalid data gracefully.

5. Error Handling & User Feedback

- Never let errors crash the UI.
- All errors must be caught and handled gracefully:
- Show toast notifications for user-facing errors (using react-toastify).
- Show fallback UI in components (e.g., “No data found”, “Failed to load”, etc.).
- Never throw errors from hooks, services, or components.
- Always log errors to the console for developer visibility.

6. Constants & Naming

- All constants must be in UPPERCASE_SNAKE_CASE.
- Filenames and variables must use camelCase.
- Exported page components should be named <Feature>Page and route containers as <Feature>PageContainer.

7. Routing

- Use Next.js pages router (not app router).
- Route files in /src/pages should only import and render the corresponding page from the module’s pages/ folder, passing query params and app-level props.
- No business logic in route files.

8. Graceful Degradation & Fallbacks

- All UI must degrade gracefully:
- If data is missing, show a friendly message (not a blank screen or error).
- If a network/API error occurs, show a toast and fallback UI.
- If a component receives invalid props, show a warning or fallback content.

9. Reusability & DRY Principle

- If a component or function is used in multiple places, move it to /src/common (base, functional, util, etc.).
- Avoid code duplication; use helpers and utilities.

10. CORS & API Environment

- Always ensure backend APIs are CORS-enabled for local development.
- Handle CORS/network errors gracefully in the UI.

11. Testing & Production Readiness

- Test all error and empty states in development.
- Remember: Next.js error overlays only appear in development; users will see your fallback UI and toasts in production.

12. Documentation & Comments

- Document all non-trivial functions and components.
- Use comments to explain “why” something is done, not “what” (the code should be self-explanatory for “what”).

Service File Standards

1. Import and Dependencies
   Always import the shared request function from ../../../common/util/api.util.js
   Use relative imports with proper path resolution

2. Function Structure and Documentation
   Every function must have JSDoc comments with:
   Clear description of what the function does
   @param tags with types and descriptions for all parameters
   @returns tag with the expected return type and description
   Use descriptive parameter names (e.g., tenantData instead of data)

3. Input Validation
   Always validate environment variables (especially NEXT_PUBLIC_BACKEND_URL)
   Validate all input parameters for type and existence
   Return appropriate fallback values when validation fails
   Log validation errors to console for debugging

4. Error Handling
   Never use try/catch blocks (the request function handles errors internally)
   Never throw errors from service functions
   Always return sensible fallback values instead of undefined/null
   Let the request function handle user-facing error notifications via toast

5. Return Value Standards
   GET operations: Return [] (empty array) for lists, null for single objects on error
   POST operations: Return null on error, actual data on success
   DELETE operations: Return boolean (true/false) to indicate success/failure
   PUT operations: Return null on error, updated data on success

6. API Call Patterns
   Use the shared request function for all HTTP operations
   Follow the pattern: request(url, method, options)
   For requests with body: { body: dataObject }
   For requests without body: omit the options parameter

7. Development and Dummy Data
   When APIs are under development, add dummy data with clear TODO comments
   Structure dummy data to match the expected API response format
   Comment out actual API calls and add explanatory comments
   Ensure dummy data covers different scenarios (empty arrays, various data states)

8. URL Construction
   Use template literals for dynamic URLs
   Always use environment variables for base URLs
   Follow RESTful conventions for endpoint paths
   Use query parameters for ID-based operations: ?id=${id}

9. Data Transformation
   Keep service functions focused on API communication
   Don't transform data in service functions (do this in hooks)
   Return raw API response data
   Let consuming components/hooks handle data formatting

10. Naming Conventions
    Function names should be descriptive and follow camelCase
    Use verb-noun pattern: getTenants, createTenant, updateTenant, deleteTenant
    Parameter names should be descriptive: tenantData, tenantId

11. Code Organization
    Group related functions together
    Export all functions as named exports
    Keep functions focused and single-purpose
    Maintain consistent spacing and formatting

12. Future-Proofing
    Always include proper validation even for simple functions
    Structure code to easily switch between dummy data and real API calls
    Use TypeScript-like JSDoc comments for better IDE support
    Document expected data structures in comments

- always prefer function over arrow function

/\*\*

- CONFIRM MODAL USAGE RULES
- ========================
-
- This is a generic confirmation modal component that can be used throughout the application
- for any confirmation dialogs. Follow these rules to ensure consistent usage:
-
- 1.  ALWAYS USE THIS COMPONENT FOR CONFIRMATIONS
- - Never create custom confirmation modals
- - Use this component for all delete, save, publish, or any destructive actions
-
- 2.  MODAL OPENING PATTERN
- - Always use useModalContext() hook to open the modal
- - Pass the ConfirmModal as the component prop
- - Set appropriate title and size
-
- 3.  BUTTON VARIANTS
- - Use "danger" for delete/destructive actions (red button)
- - Use "primary" for important confirmations (blue button)
- - Use "secondary" for cancel buttons (gray button)
-
- 4.  LOADING STATES
- - Always implement loading state for async operations
- - Use isLoading prop to disable buttons during operation
- - Provide meaningful loadingText
-
- 5.  ERROR HANDLING
- - Handle errors in the onConfirm callback
- - Show toast notifications for success/error
- - Don't close modal on error, let user retry
-
- 6.  MESSAGE CONTENT
- - Be specific about what will happen
- - Include the name of the item being affected
- - Warn about irreversible actions
- - Support both string and JSX for complex messages
-
- USAGE EXAMPLES:
-
- // Basic delete confirmation
- const handleDelete = (item) => {
- openModal({
-     title: "Delete Item",
-     component: (
-       <ConfirmModal
-         message={`Are you sure you want to delete "${item.name}"?`}
-         confirmText="Delete"
-         confirmButtonVariant="danger"
-         onConfirm={() => deleteItem(item.id)}
-         onCancel={closeModal}
-       />
-     ),
-     size: "w-96"
- });
- };
-
- // With loading state
- const [isLoading, setIsLoading] = useState(false);
- const handleSave = async () => {
- setIsLoading(true);
- try {
-     await saveData();
-     toast.success("Saved successfully");
-     closeModal();
- } catch (error) {
-     toast.error("Failed to save");
- } finally {
-     setIsLoading(false);
- }
- };
-
- // Complex message with JSX
- <ConfirmModal
- message={
-     <>
-       This will permanently delete <strong>{item.name}</strong> and all associated data.
-       <br /><br />
-       <span className="text-red-600 font-medium">This action cannot be undone.</span>
-     </>
- }
- confirmText="Delete Permanently"
- confirmButtonVariant="danger"
- onConfirm={handleDelete}
- onCancel={closeModal}
- isLoading={isLoading}
- loadingText="Deleting..."
- />
  \*/

  - write as minimun code as possible, but it should be re-bust fail safe and elegant
