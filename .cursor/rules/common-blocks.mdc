---
description: 
globs: 
alwaysApply: true
---

This rule provides standards for using and writing to /src/common folder
- It contains the following folders: base, context, functional, layouts, services and util
- base will contain the atomic building blocks, like button, dropdown, illustration, input, label, loader, multi-dropdown and toggle.
- whenever possible keep referencing the base components and if anything missing ask user before adding it.
- base components should be pure soley dependant on their props
- next comes the functional folder which contains the functional components, like breadcrumbs, table, list etc
- the functional components are a bit more complex compared to base components, they might have state and use one or more base components
- contexts will contain contexts used througout the web app like modal context, wizard context etc
- layout will contain some common layouts used throughout the application like panelLayout used for heading and description, screenLayout for breadcrumbs


1. General Principles
 - Base components are atomic, stateless, and only depend on their props. They should be as generic and reusable as possible.
 - Functional components are molecular, can have state, and are composed of base components and/or other functional components.
 - Never duplicate logic: If you need a new atomic or molecular component, add it to the appropriate folder and use it everywhere needed.
 - Always prefer composition over inheritance: Build complex UIs by composing these building blocks.

2. How to Use Existing Components

Base Components (/src/common/base)
 - Use these for all basic UI elements (Button, Input, Dropdown, Loader, Label, Toggle, MultiDropdown, Illustration).
 - Always pass all required props; check the component’s file for prop names and types.
 - Never add business logic or state to base components in your feature/module code.
 - If you need a variant (e.g., a special Button), use the className prop to extend styles, not to change logic.

Functional Components (/src/common/functional)
 - Use these for more complex UI patterns (Table, List, Tabs, PopupWrapper, PopUpMenu, Wizard, Breadcrumbs, Loading, ModalWrapper).
 - These may manage their own state and can use base components internally.
 - Always use the provided props to customize behavior (e.g., columns for Table, tabs for Tabs, menuItems for PopUpMenu).
 - Never modify these components directly in your feature/module; if you need a new feature, add it to the functional component itself or create a new one.


3. How to Add New Components

When to Add a New Base Component
 - If you need a new atomic UI element (e.g., a new type of input, icon, or visual primitive) that is not specific to any feature/module.
 - The component should be stateless, generic, and only depend on props.
 - Place it in /src/common/base, document its props, and keep it as small as possible.

When to Add a New Functional Component
 - If you need a new UI pattern that combines multiple base components (e.g., a new type of card, modal, or wizard stepper).
 - The component can have state, manage events, and use hooks.
 - Place it in /src/common/functional, document its usage, and ensure it is reusable.


4. Component Design Rules
 - Props: Always use explicit, well-documented props. Use sensible defaults.
 - Styling: Use className for style overrides. Never hardcode colors or sizes unless they are part of the design system.
 - Accessibility: Use semantic HTML and ARIA attributes where appropriate.
 - Error Handling: Base components should never throw. Functional components should handle errors gracefully and show fallback UI.
 - Loading States: Use the Loader or Loading component for all async UI.
 - Composability: Design components to be easily composed (e.g., Table uses Dropdown for filters, PopUpMenu uses Button for triggers).

 5. Naming & Structure
 - Base components: PascalCase, single responsibility, no side effects.
 - Functional components: PascalCase, can manage state, can use hooks.
 - File names: Match the component name (e.g., Button.jsx, Table.jsx).
 - Exports: Always use named exports.

 6. Extending the Library
 - Before adding a new component, check if an existing one can be reused or extended.
 - If extending, prefer adding props/options over breaking changes.
 - Document new components and their props at the top of the file.
 - If a component is used in multiple modules, it belongs in /src/common/base or /src/common/functional.

 7. Examples
 - Need a new button style? Use <Button className=\"my-custom-style\" ... /> or extend via props.
 - Need a new modal type? Add a new prop to ModalWrapper or create a new functional component if it’s a new pattern.
 - Need a new atomic input? Add it to /src/common/base and document its props.

 8. Review & Refactor
 - Regularly review /src/common/base and /src/common/functional for duplication or opportunities to generalize.
 - Refactor feature/module code to use new common components as they are added.

 By following these rules, you ensure a scalable, maintainable, and consistent UI system across your app.







